/**
 * UI Message Handler for SEI DLP Dashboard Integration
 * Handles messages from the Next.js UI and processes them through Eliza
 */

import { type Character, type Evaluator, type Memory, type Provider, type Action, type Handler, type IAgentRuntime, type State } from '@elizaos/core';
import { apiClient } from './plugin-overrides.js';

export interface UIMessage {
  content: {
    text: string;
    source: string;
  };
  user: string;
  room: string;
  context: {
    chainId: number;
    vaultAddress?: string;
    currentPage?: string;
    timestamp: string;
    vaultData?: any;
    userPreferences?: any;
  };
}

export interface UIResponse {
  response: string;
  confidence: number;
  actions: string[];
  suggestions: string[];
  responseTime: string;
  metadata?: any;
}

interface ExtendedMemoryContent {
  text: string;
  source?: string;
  metadata?: {
    chainId?: number;
    vaultAddress?: string;
    currentPage?: string;
    timestamp?: string;
    vaultData?: any;
    userPreferences?: any;
  };
  [key: string]: any; // Index signature for compatibility
}

/**
 * Message handler that processes UI messages through Eliza's AI system
 */
export class UIMessageHandler {
  private runtime: IAgentRuntime;
  private roomCache: Map<string, string> = new Map(); // user -> roomId mapping
  private entityCache: Map<string, string> = new Map(); // user -> entityId mapping

  constructor(runtime: IAgentRuntime) {
    this.runtime = runtime;
  }

  /**
   * Get or create a room ID for a user
   */
  private async getOrCreateRoomId(user: string): Promise<`${string}-${string}-${string}-${string}-${string}`> {
    let roomId = this.roomCache.get(user);
    
    if (!roomId) {
      roomId = crypto.randomUUID();
      this.roomCache.set(user, roomId);
      
      // Note: Room creation will be handled by the runtime's memory system
      console.log(`Generated room ID ${roomId} for user: ${user}`);
    }
    
    return roomId as `${string}-${string}-${string}-${string}-${string}`;
  }

  /**
   * Get or create an entity ID for a user
   */
  private async getOrCreateEntityId(user: string): Promise<`${string}-${string}-${string}-${string}-${string}`> {
    let entityId = this.entityCache.get(user);
    
    if (!entityId) {
      entityId = crypto.randomUUID();
      this.entityCache.set(user, entityId);
      
      // Note: Entity creation will be handled by the runtime's memory system
      console.log(`Generated entity ID ${entityId} for user: ${user}`);
    }
    
    return entityId as `${string}-${string}-${string}-${string}-${string}`;
  }

  /**
   * Process message from UI dashboard
   */
  async handleUIMessage(message: UIMessage): Promise<UIResponse> {
    const startTime = Date.now();
    
    try {
      // Get or create proper room and entity IDs for this user
      const roomId = await this.getOrCreateRoomId(message.user);
      const entityId = await this.getOrCreateEntityId(message.user);
      
      // Note: Room and participant connections will be handled automatically by the runtime
      
      // Create memory object for the message
      const memory: Memory = {
        id: crypto.randomUUID() as `${string}-${string}-${string}-${string}-${string}`,
        entityId,
        agentId: this.runtime.agentId,
        roomId,
        content: {
          text: message.content.text,
          source: message.content.source || 'sei-dlp-dashboard',
          metadata: {
            chainId: message.context.chainId,
            vaultAddress: message.context.vaultAddress,
            currentPage: message.context.currentPage,
            timestamp: message.context.timestamp,
            vaultData: message.context.vaultData,
            userPreferences: message.context.userPreferences
          }
        } as ExtendedMemoryContent,
        createdAt: Date.now(),
        embedding: [] // Will be generated by runtime
      };

      // Note: Memory will be automatically managed by the runtime's memory system
      // The composeState method and runtime will handle memory persistence
      console.log(`Memory prepared for room ${roomId} and entity ${entityId}`);

      // Create initial state
      const state: State = await this.runtime.composeState(memory);

      // Process the message through Eliza's evaluation and action pipeline
      const response = await this.processMessageThroughEliza(memory, state);

      const responseTime = `${Date.now() - startTime}ms`;

      return {
        response: response.text,
        confidence: response.confidence || 0.85,
        actions: response.actions || [],
        suggestions: response.suggestions || this.generateContextualSuggestions(message),
        responseTime,
        metadata: {
          processingSource: 'eliza-agent',
          chainId: message.context.chainId,
          vaultAddress: message.context.vaultAddress,
          aiEngineIntegration: response.aiEngineUsed || false
        }
      };
    } catch (error) {
      console.error('Error processing UI message:', error);
      
      // Fallback response
      return {
        response: this.generateFallbackResponse(message),
        confidence: 0.6,
        actions: [],
        suggestions: this.generateContextualSuggestions(message),
        responseTime: `${Date.now() - startTime}ms`,
        metadata: {
          processingSource: 'eliza-fallback',
          error: error instanceof Error ? error.message : 'Unknown error',
          chainId: message.context.chainId
        }
      };
    }
  }

  /**
   * Process message through Eliza's AI pipeline
   */
  private async processMessageThroughEliza(memory: Memory, state: State): Promise<{
    text: string;
    confidence?: number;
    actions?: string[];
    suggestions?: string[];
    aiEngineUsed?: boolean;
  }> {
    // Check if message is vault-related and needs AI analysis
    const messageText = (memory.content as ExtendedMemoryContent).text?.toLowerCase() || '';
    const vaultAddress = (memory.content as ExtendedMemoryContent).metadata?.vaultAddress;
    
    let aiEngineResponse = null;
    let aiEngineUsed = false;

    // Route to Python AI engine for specific queries
    if (this.shouldRouteToAIEngine(messageText, vaultAddress)) {
      try {
        aiEngineResponse = await this.callAIEngine(messageText, memory.content.metadata);
        aiEngineUsed = true;
      } catch (error) {
        console.warn('AI Engine unavailable, using Eliza-only processing:', error);
      }
    }

    // Generate response using Eliza's character and knowledge
    let responseText = '';
    let confidence = 0.85;

    if (aiEngineResponse) {
      // Incorporate AI engine results into Eliza's response
      responseText = this.formatAIEngineResponse(aiEngineResponse, messageText);
      confidence = Math.min(0.95, confidence + 0.1); // Higher confidence with AI engine
    } else {
      // Use Eliza's character-based response generation
      responseText = await this.generateCharacterResponse(memory, state);
    }

    return {
      text: responseText,
      confidence,
      actions: this.extractActions(messageText, aiEngineResponse),
      suggestions: this.generateContextualSuggestions(memory),
      aiEngineUsed
    };
  }

  /**
   * Determine if message should be routed to AI engine
   */
  private shouldRouteToAIEngine(messageText: string, vaultAddress?: string): boolean {
    const aiKeywords = [
      'predict', 'prediction', 'forecast',
      'rebalance', 'rebalancing', 'optimize',
      'range', 'optimal', 'best',
      'analysis', 'analyze', 'recommend',
      'apy', 'yield', 'returns',
      'risk', 'volatility', 'impermanent loss'
    ];

    return aiKeywords.some(keyword => messageText.includes(keyword)) || !!vaultAddress;
  }

  /**
   * Call Python AI engine for analysis
   */
  private async callAIEngine(messageText: string, metadata: any): Promise<any> {
    if (messageText.includes('predict') || messageText.includes('range') || messageText.includes('optimal')) {
      // Route to prediction endpoint
      return await apiClient.callPythonAI('/predict/optimal-range', {
        vault_address: metadata.vaultAddress || '0x0000000000000000000000000000000000000000',
        current_price: 1.0, // Would get from market data
        volume_24h: 1000000,
        volatility: 0.25,
        liquidity: 5000000,
        timeframe: '1d',
        chain_id: metadata.chainId || 713715
      });
    } else if (messageText.includes('rebalance')) {
      // Route to rebalance analysis
      return await apiClient.callPythonAI('/analyze/rebalance', {
        vault_address: metadata.vaultAddress || '0x0000000000000000000000000000000000000000',
        current_tick: 0,
        lower_tick: -1000,
        upper_tick: 1000,
        utilization_rate: 0.5,
        market_conditions: {
          tvl: 1000000,
          impermanent_loss: -0.5,
          last_rebalance: new Date().toISOString()
        }
      });
    }

    return null;
  }

  /**
   * Format AI engine response into natural language
   */
  private formatAIEngineResponse(aiResponse: any, originalMessage: string): string {
    if (aiResponse.lower_price && aiResponse.upper_price) {
      // Prediction response
      return `ðŸŽ¯ Based on SEI AI Engine analysis: Optimal range is $${aiResponse.lower_price.toFixed(4)} - $${aiResponse.upper_price.toFixed(4)} with ${(aiResponse.confidence * 100).toFixed(1)}% confidence. Expected APR: ${(aiResponse.expected_apr * 100).toFixed(2)}%. ${aiResponse.reasoning || 'This range optimizes fee capture while minimizing impermanent loss risk.'}`;
    } else if (aiResponse.action && aiResponse.urgency) {
      // Rebalance response
      return `âš¡ AI Rebalance Analysis: ${aiResponse.action.replace('_', ' ')} (${aiResponse.urgency} priority). Expected improvement: ${(aiResponse.expected_improvement || 0).toFixed(2)}%. Gas cost: ~$${(aiResponse.gas_cost_estimate || 0.15).toFixed(3)} on SEI. ${aiResponse.risk_assessment || 'Rebalancing recommended for optimal capital efficiency.'}`;
    }

    return `ðŸ¤– AI Engine analysis complete. ${aiResponse.reasoning || 'Check the dashboard for detailed metrics and recommendations.'}`;
  }

  /**
   * Generate character-based response using Eliza's AI models
   */
  private async generateCharacterResponse(memory: Memory, state: State): Promise<string> {
    try {
      // Use the runtime's message handler to get an AI-generated response
      const response = await this.runtime.messageHandlers[0].handler(
        this.runtime,
        memory,
        state,
        { isCharacterResponse: true },
        async (content) => {
          // This callback is called when the AI generates a response
          console.log('AI generated response:', content.text);
        }
      );

      if (response && response.text) {
        return response.text;
      }

      // If no response from AI, check for price-related queries and fetch real data
      const messageText = (memory.content as ExtendedMemoryContent).text?.toLowerCase() || '';
      
      if (messageText.includes('price') && messageText.includes('sei')) {
        try {
          // Fetch real SEI price data from the frontend API
          const apiUrl = process.env.MAIN_PROJECT_API || 'http://localhost:3001';
          const response = await fetch(`${apiUrl}/api/market/data?symbols=SEI-USDC`);
          const data = await response.json();
          
          if (data.success && data.data && data.data[0]) {
            const seiData = data.data[0];
            const price = seiData.price;
            const change = seiData.change24h;
            const changePercent = seiData.changePercent24h;
            
            return `ðŸŽ¯ Current SEI price: $${price.toFixed(2)} USD. 24h change: ${change >= 0 ? '+' : ''}$${change.toFixed(3)} (${changePercent >= 0 ? '+' : ''}${changePercent.toFixed(2)}%). SEI's 400ms finality makes it perfect for active DLP strategies!`;
          }
        } catch (error) {
          console.warn('Failed to fetch real market data:', error);
        }
      }

      // Fallback to default SEI DLP specialist response
      return `ðŸ¤– I'm Liqui, your SEI DLP specialist! I can help with vault optimization, rebalancing strategies, yield predictions, and risk assessment. What specific aspect of your liquidity position would you like to explore?`;
    } catch (error) {
      console.error('Error generating character response:', error);
      
      // Enhanced fallback with real market data if available
      const messageText = (memory.content as ExtendedMemoryContent).text?.toLowerCase() || '';
      
      if (messageText.includes('price') && messageText.includes('sei')) {
        return `ðŸ’° I can help you check SEI prices and market data! Our system integrates with real-time APIs to provide accurate pricing for your DLP strategies.`;
      }
      
      return `âš¡ SEI's 400ms finality is perfect for active liquidity management! How can I help optimize your yield strategies today?`;
    }
  }

  /**
   * Extract actionable items from the message
   */
  private extractActions(messageText: string, aiResponse: any): string[] {
    const actions: string[] = [];
    
    if (messageText.includes('rebalance')) {
      actions.push('ANALYZE_REBALANCE', 'CHECK_GAS_COSTS');
    }
    
    if (messageText.includes('deposit') || messageText.includes('withdraw')) {
      actions.push('REVIEW_POSITION', 'CALCULATE_IMPACT');
    }
    
    if (messageText.includes('predict') || messageText.includes('forecast')) {
      actions.push('RUN_PREDICTION_MODEL', 'ANALYZE_MARKET_DATA');
    }
    
    if (aiResponse?.action === 'rebalance_required') {
      actions.push('EXECUTE_REBALANCE', 'MONITOR_POSITION');
    }
    
    return actions;
  }

  /**
   * Generate contextual suggestions based on message and context
   */
  private generateContextualSuggestions(message: UIMessage | Memory): string[] {
    const suggestions: string[] = [];
    let text = '';
    let context: any = {};
    
    if ('content' in message && 'context' in message) {
      // UIMessage
      text = (message as UIMessage).content.text;
      context = (message as UIMessage).context;
    } else {
      // Memory
      text = (message as Memory).content.text || '';
      context = ((message as Memory).content as ExtendedMemoryContent).metadata || {};
    }
    
    // Context-aware suggestions
    if (context?.vaultAddress) {
      suggestions.push(
        `Analyze vault ${context.vaultAddress.slice(0, 8)}... performance`,
        `Check rebalancing opportunities for this vault`,
        `Review risk metrics and IL exposure`
      );
    } else {
      suggestions.push(
        'Show me the best performing vaults',
        'What are current SEI DLP yields?',
        'Explain SEI advantages for liquidity provision'
      );
    }
    
    if (text.toLowerCase().includes('gas') || text.toLowerCase().includes('cost')) {
      suggestions.push(
        'Compare gas costs: SEI vs Ethereum',
        'Calculate rebalancing profitability'
      );
    }
    
    // Always include general help
    suggestions.push(
      'Help me optimize my yield strategy',
      'Show me AI predictions for next 24h'
    );
    
    return suggestions.slice(0, 4); // Limit to 4 suggestions
  }

  /**
   * Generate fallback response for errors
   */
  private generateFallbackResponse(message: UIMessage): string {
    const messageText = message.content.text.toLowerCase();
    
    if (messageText.includes('rebalance')) {
      return `âš¡ For rebalancing assistance, I recommend checking your vault's utilization rate. If it's below 60%, rebalancing could improve fee capture. SEI's 400ms finality makes this cost-effective at ~$0.15 per transaction.`;
    }
    
    if (messageText.includes('vault') && message.context.vaultAddress) {
      return `ðŸŽ¯ I'm analyzing vault ${message.context.vaultAddress.slice(0, 8)}... on SEI Chain 713715. Check the dashboard for current metrics or ask me specific questions about optimization strategies.`;
    }
    
    return `ðŸ¤– I'm Liqui, your SEI DLP AI assistant. I specialize in vault optimization, yield strategies, and rebalancing recommendations. The main dashboard has detailed analytics, or you can ask me specific questions about your positions.`;
  }
}

/**
 * Express route handler for UI messages
 */
export function createUIMessageRoute(runtime: IAgentRuntime) {
  const handler = new UIMessageHandler(runtime);
  
  return async (req: any, res: any) => {
    try {
      const message: UIMessage = req.body;
      
      // Validate message structure
      if (!message.content?.text || !message.user || !message.context?.chainId) {
        return res.status(400).json({
          success: false,
          error: 'Invalid message format',
          required: ['content.text', 'user', 'context.chainId']
        });
      }
      
      // Process message
      const response = await handler.handleUIMessage(message);
      
      res.json({
        success: true,
        ...response
      });
    } catch (error) {
      console.error('UI message route error:', error);
      res.status(500).json({
        success: false,
        error: 'Failed to process message',
        details: error instanceof Error ? error.message : 'Unknown error'
      });
    }
  };
}