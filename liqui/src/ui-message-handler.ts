/**
 * UI Message Handler for SEI DLP Dashboard Integration
 * Handles messages from the Next.js UI and processes them through Eliza
 */

import { type Character, type Evaluator, type Memory, type Provider, type Action, type Handler, type IAgentRuntime, type State, type Content, type Room, type Entity, ChannelType, type UUID } from '@elizaos/core';
import { apiClient } from './plugin-overrides.js';

export interface UIMessage {
  content: {
    text: string;
    source: string;
  };
  user: string;
  room: string;
  context: {
    chainId: number;
    vaultAddress?: string;
    currentPage?: string;
    timestamp: string;
    vaultData?: any;
    userPreferences?: any;
  };
}

export interface UIResponse {
  response: string;
  confidence: number;
  actions: string[];
  suggestions: string[];
  responseTime: string;
  metadata?: any;
}

interface ExtendedMemoryContent {
  text: string;
  source?: string;
  metadata?: {
    chainId?: number;
    vaultAddress?: string;
    currentPage?: string;
    timestamp?: string;
    vaultData?: any;
    userPreferences?: any;
  };
  [key: string]: any; // Index signature for compatibility
}

/**
 * Message handler that processes UI messages through Eliza's AI system
 */
export class UIMessageHandler {
  private runtime: IAgentRuntime;
  private roomCache: Map<string, string> = new Map(); // user -> roomId mapping
  private entityCache: Map<string, string> = new Map(); // user -> entityId mapping

  constructor(runtime: IAgentRuntime) {
    this.runtime = runtime;
  }

  /**
   * Get or create a room ID for a user
   */
  private async getOrCreateRoomId(user: string): Promise<`${string}-${string}-${string}-${string}-${string}`> {
    let roomId = this.roomCache.get(user);
    
    if (!roomId) {
      roomId = crypto.randomUUID();
      this.roomCache.set(user, roomId);
      console.log(`Generated room ${roomId} for user: ${user}`);
    }
    
    return roomId as `${string}-${string}-${string}-${string}-${string}`;
  }

  /**
   * Get or create an entity ID for a user and establish connection with room
   */
  private async getOrCreateEntityId(user: string, roomId: UUID): Promise<`${string}-${string}-${string}-${string}-${string}`> {
    let entityId = this.entityCache.get(user);
    
    if (!entityId) {
      entityId = crypto.randomUUID();
      this.entityCache.set(user, entityId);
      
      // Create the entity properly using ElizaOS runtime methods
      try {
        // Use the correct ElizaOS method to ensure connection exists
        await this.runtime.ensureConnection({
          entityId: entityId as UUID,
          userId: entityId as UUID, // userId should be same as entityId for user entities
          roomId: roomId,
          userName: user,
          name: user,
          source: 'sei-dlp-dashboard',
          type: ChannelType.DM,
          worldId: '00000000-0000-0000-0000-000000000000' as UUID,
          serverId: '00000000-0000-0000-0000-000000000000' as UUID // Add server ID
        });
        console.log(`Created/ensured entity ${entityId} for user: ${user}`);
      } catch (error) {
        console.warn(`Failed to create entity ${entityId}:`, error);
      }
    }
    
    return entityId as `${string}-${string}-${string}-${string}-${string}`;
  }

  /**
   * Process message from UI dashboard
   */
  async handleUIMessage(message: UIMessage): Promise<UIResponse> {
    const startTime = Date.now();
    
    try {
      // Get or create proper room and entity IDs for this user
      const roomId = await this.getOrCreateRoomId(message.user);
      const entityId = await this.getOrCreateEntityId(message.user, roomId);
      
      // Ensure the participant is properly connected to the room
      try {
        await this.runtime.ensureParticipantInRoom(entityId, roomId);
        console.log(`Ensured participant ${entityId} is in room ${roomId}`);
      } catch (error) {
        console.warn(`Failed to link participant to room:`, error);
      }
      
      console.log(`Memory prepared for room ${roomId} and entity ${entityId}`);
      
      
      // Create memory object for the message
      const memory: Memory = {
        id: crypto.randomUUID() as `${string}-${string}-${string}-${string}-${string}`,
        entityId,
        agentId: this.runtime.agentId,
        roomId,
        content: {
          text: message.content.text,
          source: message.content.source || 'sei-dlp-dashboard',
          metadata: {
            chainId: message.context.chainId,
            vaultAddress: message.context.vaultAddress,
            currentPage: message.context.currentPage,
            timestamp: message.context.timestamp,
            vaultData: message.context.vaultData,
            userPreferences: message.context.userPreferences
          }
        } as ExtendedMemoryContent,
        createdAt: Date.now(),
        embedding: [] // Will be generated by runtime
      };

      // Note: Memory will be automatically managed by the runtime's memory system
      // The composeState method and runtime will handle memory persistence
      console.log(`Memory prepared for room ${roomId} and entity ${entityId}`);

      // Create initial state
      const state: State = await this.runtime.composeState(memory);

      // Process the message through Eliza's evaluation and action pipeline
      const response = await this.processMessageThroughEliza(memory, state);

      const responseTime = `${Date.now() - startTime}ms`;

      return {
        response: response.text,
        confidence: response.confidence || 0.85,
        actions: response.actions || [],
        suggestions: response.suggestions || this.generateContextualSuggestions(message),
        responseTime,
        metadata: {
          processingSource: 'eliza-agent',
          chainId: message.context.chainId,
          vaultAddress: message.context.vaultAddress,
          aiEngineIntegration: response.aiEngineUsed || false
        }
      };
    } catch (error) {
      console.error('Error processing UI message:', error);
      
      // Fallback response
      return {
        response: this.generateFallbackResponse(message),
        confidence: 0.6,
        actions: [],
        suggestions: this.generateContextualSuggestions(message),
        responseTime: `${Date.now() - startTime}ms`,
        metadata: {
          processingSource: 'eliza-fallback',
          error: error instanceof Error ? error.message : 'Unknown error',
          chainId: message.context.chainId
        }
      };
    }
  }

  /**
   * Process message through Eliza's AI pipeline
   */
  private async processMessageThroughEliza(memory: Memory, state: State): Promise<{
    text: string;
    confidence?: number;
    actions?: string[];
    suggestions?: string[];
    aiEngineUsed?: boolean;
  }> {
    // Check if message is vault-related and needs AI analysis
    const messageText = (memory.content as ExtendedMemoryContent).text?.toLowerCase() || '';
    const vaultAddress = (memory.content as ExtendedMemoryContent).metadata?.vaultAddress;
    
    let aiEngineResponse = null;
    let aiEngineUsed = false;

    // Route to Python AI engine for specific queries
    if (this.shouldRouteToAIEngine(messageText, vaultAddress)) {
      try {
        aiEngineResponse = await this.callAIEngine(messageText, memory.content.metadata);
        aiEngineUsed = true;
      } catch (error) {
        console.warn('AI Engine unavailable, using Eliza-only processing:', error);
      }
    }

    // Generate response using Eliza's character and knowledge
    let responseText = '';
    let confidence = 0.85;

    if (aiEngineResponse) {
      // Incorporate AI engine results into Eliza's response
      responseText = this.formatAIEngineResponse(aiEngineResponse, messageText);
      confidence = Math.min(0.95, confidence + 0.1); // Higher confidence with AI engine
    } else {
      // Use Eliza's character-based response generation
      responseText = await this.generateCharacterResponse(memory);
    }

    return {
      text: responseText,
      confidence,
      actions: this.extractActions(messageText, aiEngineResponse),
      suggestions: this.generateContextualSuggestions(memory),
      aiEngineUsed
    };
  }

  /**
   * Determine if message should be routed to AI engine
   */
  private shouldRouteToAIEngine(messageText: string, vaultAddress?: string): boolean {
    const aiKeywords = [
      'predict', 'prediction', 'forecast',
      'rebalance', 'rebalancing', 'optimize',
      'range', 'optimal', 'best',
      'analysis', 'analyze', 'recommend',
      'apy', 'yield', 'returns',
      'risk', 'volatility', 'impermanent loss'
    ];

    return aiKeywords.some(keyword => messageText.includes(keyword)) || !!vaultAddress;
  }

  /**
   * Call Python AI engine for analysis
   */
  private async callAIEngine(messageText: string, metadata: any): Promise<any> {
    if (messageText.includes('predict') || messageText.includes('range') || messageText.includes('optimal')) {
      // Route to prediction endpoint
      return await apiClient.callPythonAI('/predict/optimal-range', {
        vault_address: metadata.vaultAddress || '0x0000000000000000000000000000000000000000',
        current_price: 1.0, // Would get from market data
        volume_24h: 1000000,
        volatility: 0.25,
        liquidity: 5000000,
        timeframe: '1d',
        chain_id: metadata.chainId || 1328
      });
    } else if (messageText.includes('rebalance')) {
      // Route to rebalance analysis
      return await apiClient.callPythonAI('/analyze/rebalance', {
        vault_address: metadata.vaultAddress || '0x0000000000000000000000000000000000000000',
        current_tick: 0,
        lower_tick: -1000,
        upper_tick: 1000,
        utilization_rate: 0.5,
        market_conditions: {
          tvl: 1000000,
          impermanent_loss: -0.5,
          last_rebalance: new Date().toISOString()
        }
      });
    }

    return null;
  }

  /**
   * Format AI engine response into natural language
   */
  private formatAIEngineResponse(aiResponse: any, originalMessage: string): string {
    if (aiResponse.lower_price && aiResponse.upper_price) {
      // Prediction response
      return `🎯 Based on SEI AI Engine analysis: Optimal range is $${aiResponse.lower_price.toFixed(4)} - $${aiResponse.upper_price.toFixed(4)} with ${(aiResponse.confidence * 100).toFixed(1)}% confidence. Expected APR: ${(aiResponse.expected_apr * 100).toFixed(2)}%. ${aiResponse.reasoning || 'This range optimizes fee capture while minimizing impermanent loss risk.'}`;
    } else if (aiResponse.action && aiResponse.urgency) {
      // Rebalance response
      return `⚡ AI Rebalance Analysis: ${aiResponse.action.replace('_', ' ')} (${aiResponse.urgency} priority). Expected improvement: ${(aiResponse.expected_improvement || 0).toFixed(2)}%. Gas cost: ~$${(aiResponse.gas_cost_estimate || 0.15).toFixed(3)} on SEI. ${aiResponse.risk_assessment || 'Rebalancing recommended for optimal capital efficiency.'}`;
    }

    return `🤖 AI Engine analysis complete. ${aiResponse.reasoning || 'Check the dashboard for detailed metrics and recommendations.'}`;
  }

  /**
   * Generate character-based response using Eliza's AI models
   */
  private async generateCharacterResponse(memory: Memory): Promise<string> {
    try {
      // For now, use intelligent fallback responses
      // TODO: Integrate with Eliza's model API once properly configured
      console.log('Using character-based fallback response generation');
      
      const messageText = (memory.content as ExtendedMemoryContent).text?.toLowerCase() || '';
      return this.generateIntelligentFallback(messageText, memory);
      
    } catch (error) {
      console.error('Error generating character response:', error);
      return `⚡ SEI's 400ms finality is perfect for active liquidity management! How can I help optimize your yield strategies today?`;
    }
  }

  /**
   * Generate intelligent fallback responses based on message content with improved context awareness
   */
  private generateIntelligentFallback(messageText: string, memory: Memory): string {
    const vaultAddress = (memory.content as ExtendedMemoryContent).metadata?.vaultAddress;
    
    // Check for follow-up questions or clarifications first (better UX)
    if (messageText.includes('specifically') || messageText.includes('answer that') || messageText.includes('asked about')) {
      if (messageText.includes('benefit') || messageText.includes('sei')) {
        return `🔍 You're right - let me be specific about SEI benefits: **Speed**: 400ms finality vs 12+ seconds on Ethereum, **Cost**: $0.15 vs $20+ gas fees, **Efficiency**: parallel processing enables better price discovery, **Yield**: typically 15-30% higher returns due to active management being profitable. Want details on any specific aspect?`;
      }
    }

    // Enhanced SEI benefits responses
    if (messageText.includes('benefit') && messageText.includes('sei')) {
      return `💡 SEI's key benefits for DLP: 1) **400ms finality** = faster rebalancing, 2) **~$0.15 gas** = profitable micro-adjustments, 3) **Parallel execution** = better DEX performance, 4) **Built-in orderbook** = deeper liquidity. These advantages typically result in 15-30% higher yields compared to Ethereum!`;
    }

    if (messageText.includes('sei') && (messageText.includes('chain') || messageText.includes('blockchain') || messageText.includes('architecture'))) {
      return `📊 SEI's blockchain architecture is perfect for liquidity provision! The 400ms block time means you can react to market changes almost instantly, while the low gas costs (~$0.15) make frequent rebalancing profitable. This combination allows for more active strategies and better capital efficiency than slower, expensive chains.`;
    }

    // Price queries
    if (messageText.includes('price') && messageText.includes('sei')) {
      return `💰 Current SEI price is approximately $0.30! SEI's unique architecture with 400ms finality and ~$0.15 transaction costs makes it ideal for active liquidity strategies. The lower price point creates great opportunities for accumulation and yield farming. Would you like me to help analyze your vault performance?`;
    }

    // Rebalancing queries
    if (messageText.includes('rebalance') || messageText.includes('rebalancing')) {
      return `⚡ Rebalancing on SEI is incredibly cost-effective! With ~$0.15 gas costs, you can rebalance frequently without eating into profits. I recommend rebalancing when utilization drops below 60% or when price moves beyond your active range. ${vaultAddress ? `For vault ${vaultAddress.slice(0, 8)}..., ` : ''}check the dashboard for current metrics!`;
    }

    // Vault-specific queries
    if (vaultAddress) {
      return `🎯 Analyzing vault ${vaultAddress.slice(0, 8)}... on SEI! This vault benefits from SEI's lightning-fast 400ms finality. Check the dashboard for detailed metrics like TVL, APY, and impermanent loss. Need help optimizing your position or exploring rebalancing strategies?`;
    }

    // Yield/APY queries
    if (messageText.includes('yield') || messageText.includes('apy') || messageText.includes('return')) {
      return `📈 SEI DLP yields are typically 15-30% higher than Ethereum due to low gas costs enabling active management! With rebalancing costs at just ~$0.15, you can capture more fees and minimize IL. Check the vaults dashboard for current opportunities!`;
    }

    // General greeting or help
    if (messageText.includes('hello') || messageText.includes('hi') || messageText.includes('help')) {
      return `👋 Hello! I'm Liqui, your SEI DLP AI assistant! I specialize in vault optimization, rebalancing strategies, and yield maximization on SEI's lightning-fast blockchain. SEI's 400ms finality and ~$0.15 gas costs make it perfect for active liquidity provision. How can I help optimize your strategy today?`;
    }

    // Default response with variation to reduce repetition
    const defaultResponses = [
      `🤖 I'm Liqui, your SEI DLP specialist! I can help with vault analysis, rebalancing strategies, yield optimization, and risk assessment. SEI's 400ms finality makes it perfect for active liquidity management. What would you like to explore?`,
      `🔄 I can help with more specific details about SEI DLP strategies! Feel free to ask about vault analysis, rebalancing optimization, yield calculations, or risk management. What specific aspect would you like to explore further?`,
      `⚡ Ready to help optimize your SEI DLP experience! I specialize in yield strategies, vault performance, and rebalancing recommendations. SEI's low gas costs make active management profitable. How can I assist you?`
    ];
    
    // Use a simple rotation based on message length to add variety
    const responseIndex = messageText.length % defaultResponses.length;
    return defaultResponses[responseIndex];
  }

  /**
   * Extract actionable items from the message
   */
  private extractActions(messageText: string, aiResponse: any): string[] {
    const actions: string[] = [];
    
    if (messageText.includes('rebalance')) {
      actions.push('ANALYZE_REBALANCE', 'CHECK_GAS_COSTS');
    }
    
    if (messageText.includes('deposit') || messageText.includes('withdraw')) {
      actions.push('REVIEW_POSITION', 'CALCULATE_IMPACT');
    }
    
    if (messageText.includes('predict') || messageText.includes('forecast')) {
      actions.push('RUN_PREDICTION_MODEL', 'ANALYZE_MARKET_DATA');
    }
    
    if (aiResponse?.action === 'rebalance_required') {
      actions.push('EXECUTE_REBALANCE', 'MONITOR_POSITION');
    }
    
    return actions;
  }

  /**
   * Generate contextual suggestions based on message and context
   */
  private generateContextualSuggestions(message: UIMessage | Memory): string[] {
    const suggestions: string[] = [];
    let text = '';
    let context: any = {};
    
    if ('content' in message && 'context' in message) {
      // UIMessage
      text = (message as UIMessage).content.text;
      context = (message as UIMessage).context;
    } else {
      // Memory
      text = (message as Memory).content.text || '';
      context = ((message as Memory).content as ExtendedMemoryContent).metadata || {};
    }
    
    // Context-aware suggestions
    if (context?.vaultAddress) {
      suggestions.push(
        `Analyze vault ${context.vaultAddress.slice(0, 8)}... performance`,
        `Check rebalancing opportunities for this vault`,
        `Review risk metrics and IL exposure`
      );
    } else {
      suggestions.push(
        'Show me the best performing vaults',
        'What are current SEI DLP yields?',
        'Explain SEI advantages for liquidity provision'
      );
    }
    
    if (text.toLowerCase().includes('gas') || text.toLowerCase().includes('cost')) {
      suggestions.push(
        'Compare gas costs: SEI vs Ethereum',
        'Calculate rebalancing profitability'
      );
    }
    
    // Always include general help
    suggestions.push(
      'Help me optimize my yield strategy',
      'Show me AI predictions for next 24h'
    );
    
    return suggestions.slice(0, 4); // Limit to 4 suggestions
  }

  /**
   * Generate fallback response for errors
   */
  private generateFallbackResponse(message: UIMessage): string {
    const messageText = message.content.text.toLowerCase();
    
    if (messageText.includes('rebalance')) {
      return `⚡ For rebalancing assistance, I recommend checking your vault's utilization rate. If it's below 60%, rebalancing could improve fee capture. SEI's 400ms finality makes this cost-effective at ~$0.15 per transaction.`;
    }
    
    if (messageText.includes('vault') && message.context.vaultAddress) {
      return `🎯 I'm analyzing vault ${message.context.vaultAddress.slice(0, 8)}... on SEI Chain 1328. Check the dashboard for current metrics or ask me specific questions about optimization strategies.`;
    }
    
    return `🤖 I'm Liqui, your SEI DLP AI assistant. I specialize in vault optimization, yield strategies, and rebalancing recommendations. The main dashboard has detailed analytics, or you can ask me specific questions about your positions.`;
  }
}

/**
 * Express route handler for UI messages
 */
export function createUIMessageRoute(runtime: IAgentRuntime) {
  const handler = new UIMessageHandler(runtime);
  
  return async (req: any, res: any) => {
    try {
      const message: UIMessage = req.body;
      
      // Validate message structure
      if (!message.content?.text || !message.user || !message.context?.chainId) {
        return res.status(400).json({
          success: false,
          error: 'Invalid message format',
          required: ['content.text', 'user', 'context.chainId']
        });
      }
      
      // Process message
      const response = await handler.handleUIMessage(message);
      
      res.json({
        success: true,
        ...response
      });
    } catch (error) {
      console.error('UI message route error:', error);
      res.status(500).json({
        success: false,
        error: 'Failed to process message',
        details: error instanceof Error ? error.message : 'Unknown error'
      });
    }
  };
}